# 2. 硬件结构



## 2.1 CPU是如何执行程序的



### 2.1.1 图灵机的工作方式

图灵机的基本组成如下：

- 有一条「纸带」，纸带由一个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序；

- 有一个「读写头」，读写头可以读取纸带上任意格子的字符，也可以把字符写入到纸带的格子；

- 读写头上有一些部件，比如存储单元、控制单元以及运算单元： 

  1、存储单元用于存放数据；

  2、控制单元用于识别字符是数据还是指令，以及控制程序的流程等； 

  3、运算单元用于执行运算指令；

知道了图灵机的组成后，我们以简单数学运算的 `1 + 2` 作为例子，来看看它是怎么执行这行代码的：

- 首先，用读写头把 「1、2、+」这 3 个字符分别写入到纸带上的 3 个格子，然后读写头先停在 1 字符对应的格子上；

  ![截屏2024-10-16 16.58.13](/Users/aris/Library/Application Support/typora-user-images/截屏2024-10-16 16.58.13.png)

- 接着，读写头读入 1 到存储设备中，这个存储设备称为图灵机的状态；

  ![截屏2024-10-16 16.58.42](/Users/aris/Library/Application Support/typora-user-images/截屏2024-10-16 16.58.42.png)

- 然后读写头向右移动一个格，用同样的方式把 2 读入到图灵机的状态，于是现在图灵机的状态中存储着两个连续的数字， 1 和 2；

  ![截屏2024-10-16 17.01.05](/Users/aris/Library/Application Support/typora-user-images/截屏2024-10-16 17.01.05.png)

- 读写头再往右移动一个格，就会碰到 + 号，读写头读到 + 号后，将 + 号传输给「控制单元」，控制单元发现是一个 + 号而不是数字，所以没有存入到状态中，因为 `+` 号是运算符指令，作用是加和目前的状态，于是通知「运算单元」工作。运算单元收到要加和状态中的值的通知后，就会把状态中的 1 和 2 读入并计算，再将计算的结果 3 存放到状态中；

  ![截屏2024-10-16 17.02.26](/Users/aris/Library/Application Support/typora-user-images/截屏2024-10-16 17.02.26.png)

- 最后，运算单元将结果返回给控制单元，控制单元将结果传输给读写头，读写头向右移动，把结果 3 写入到纸带的格子中；

  ![截屏2024-10-16 17.03.01](/Users/aris/Library/Application Support/typora-user-images/截屏2024-10-16 17.03.01.png)

总结：通过上面的图灵机计算 `1 + 2` 的过程，可以发现图灵机主要功能就是读取纸带格子中的内容，然后交给控制单元识别字符是数字还是运算符指令，如果是数字则存入到图灵机状态中，如果是运算符，则通知运算符单元读取状态中的数值进行计算，计算结果最终返回给读写头，读写头把结果写入到纸带的格子中。

事实上，图灵机这个看起来很简单的工作方式，和我们今天的计算机是基本一样的。



### 2.1.2 冯诺依曼模型

冯诺依曼遵循了图灵机的设计,而且还提出用电子元件构造计算机，并约定了用二进制进行计算和存储。

最重要的是定义计算机基本结构为 5 个部分，分别是**运算器、控制器、存储器、输入设备、输出设备**，这 5 个部分也被称为**冯诺依曼模型**。

![截屏2024-10-17 23.54.12](/Users/aris/Library/Application Support/typora-user-images/截屏2024-10-17 23.54.12.png)

运算器、控制器是在中央处理器里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备。

存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：

![截屏2024-10-17 23.55.16](/Users/aris/Library/Application Support/typora-user-images/截屏2024-10-17 23.55.16.png)

- 内存

  我们的程序和数据都是存储在内存，存储的区域是线性的。

  在计算机数据存储中，存储数据的基本单位是**字节（\*byte\*）**，1 字节等于 8  bit 。

  每一个字节都对应一个内存地址。内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。

  

- CPU

  中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：

  - 32 位 CPU 一次可以计算 4 个字节；
  - 64 位 CPU 一次可以计算 8 个字节；

​	这里的 32 位和 64 位，通常称为 CPU 的位	宽，代表的是 CPU 一次可以计算（运算）	的数据量。

​	之所以 CPU 要这样设计，是为了能计算更大	的数值，如果是 8 位的 CPU，那么一次只能计	算 1 个字节 `0~255` 范围内的数值，这样就无	法一次完成计算 `10000 * 500` ，于是为了能	一次计算大数的运算，CPU 需要支持多个 	byte 一起计算，所以 CPU 位宽越大，可以计	算的数值就越大，比如说 32 位 CPU 能计算的	最大整数是 `4294967295`。

​	CPU 内部还有一些组件，常见的有**寄存器、	控制单元和逻辑运算单元**等。其中，控制单元  	负责控制 CPU 工作，逻辑运算单元负责计	算，而寄存器可以分为多种类，每种寄存器的	功能又不尽相同。

​	CPU 中的寄存器主要作用是存储计算时的数	据，你可能好奇为什么有了内存还需要寄存	器？原因很简单，因为内存离 CPU 太远了，	而寄存器就在 CPU 里，还紧挨着控制单元和	逻辑运算单元，自然计算时速度会很快。

​	常见的寄存器种类：

​	*通用寄存器*，用来存放需要进行运算的数据，	比如需要进行加和运算的两个数据。

​	*程序计数器*，用来存储 CPU 要执行下一条指	令「所在的内存地址」，注意不是存储了下一	条要执行的指令，此时指令还在内存中，程序	计数器只是存储了下一条指令「的地址」。

​	*指令寄存器*，用来存放当前正在执行的指令，	也就是指令本身，指令被执行完成之前，指令	都存储在这里。

- 总线

  总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：

  - *地址总线*，用于指定 CPU 将要操作的内存地址；
  - *数据总线*，用于读写内存的数据；
  - *控制总线*，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；

  当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：

  - 首先要通过「地址总线」来指定内存的地址；
  - 然后通过「控制总线」控制是读或写命令；
  - 最后通过「数据总线」来传输数据；

- 输入输出设备

  输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。



### 线路位宽与 CPU 位宽

数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。

如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。

这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。

为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。

CPU 想要操作「内存地址」就需要「地址总线」：

- 如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2 个（注意，不要理解成同时能操作 2 个内存地址）；
- 如果地址总线有 2 条，那么能表示 00、01、10、11这四种地址，所以 CPU 能操作的内存地址最大数量为 4 个。

那么，想要 CPU 操作 4G 大的内存，那么就需要32 条地址总线，因为 $2^{32}$ = 4G

知道了线路位宽的意义后，我们再来看看 CPU 位宽。

CPU 的位宽最好不要小于线路位宽，比如 32 位CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。

如果用 32 位 CPU 去加和两个 64 位大小的数字，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。

对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。

但是并不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以**如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来**

另外，32 位 CPU 最大只能操作 4GB 内存，就算你装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 $2^{64}$



### 程序执行的基本过程

在前面，我们知道了程序在图灵机的执行过程，接下来我们来看看程序在冯诺依曼模型上是怎么执行的。

程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。

那 CPU 执行程序的过程如下：

第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令存入到「指令寄存器」。

第二步，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；

第三步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则由「控制单元」执行；

简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。

CPU 从程序计数器读取指令，到执行一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 CPU 的指令周期。

![截屏2024-10-19 17.09.51](/Users/aris/Library/Application Support/typora-user-images/截屏2024-10-19 17.09.51.png)



### a = 1 + 2 执行具体过程







